/*Задание 2

Составьте SQL-запросы. Придумайте, как оценить показатели, и напишите запросы для расчёта придуманных метрик. 
Представьте, что в вашем распоряжении есть все ресурсы по сбору статистики. Если вам необходимы дополнительные данные, 
то опишите, чего не хватает в тестовой базе, чтобы посчитать нужные метрики.*/

select * from content_watch w left join content_info  i on w.content_id=i.content_id;

/*1.	"Цепляемость" и "крутость" сериала. Нужна какая-то метрика, которая при наличии трёх-четырёх серий сериала позволит 
сравнить этот сериал по "крутости" с другими сериалами.

Варианты:
- "ретеншн" по сериям (выбираю ее как самую интерпретируемую и устойчивую к внешним влияниям)
	- нужно определить, что считать просмотром серии
	- непонятно, что делать с теми, кто начинает смотреть не с первой серии
	- не него могут влиять специфичные акции
	
- повторные просмотры одного пользователя
	- может быть как из-за "цепляемости", так и из-за показов родственникам
	- накручивается при перебоях с интернетом у пользователя
	
- средняя продолжительность просмотра от длительности серии
	- влияет реклама и перебои со связью
	
- разница для последней между исследуемым сериалом и остальным контентом, который смотрит отдельный пользователь
	- данные слишком разнесены по времени
	
Как считаем:
 coolness = # посмотревших все серии до серии N вкл / # посмотревших 1-ю серию
 просмотр = 70% длительности (для учета перемотки повтора и титров) 
*/


-- запрос будет примерно такой (не работает из-за недостающих данных)
with first_watch as (select count(distinct user_id) from content_watch w left join content_info  i on w.content_id=i.content_id
where compilation_id = /*id нужного сериала*/ -- нужна таблица с названиями и id контента
and episode = 1
and show_duration >= 0.75*/*длительность серии*/)

select 100*count(*)/first_watch from 
(select user_id from content_watch w left join content_info  i on w.content_id=i.content_id
where compilation_id = /*id нужного сериала*/ -- нужна таблица с названиями и id контента
and episode between 1 and N
and show_duration >= 0.75*/*длительность серии*/
group by user_id
having count(*)= N)



/*2.	Ретеншн всех пользователей сервиса. Нужно просегментировать аудиторию, рассчитать её ретеншн по сегментам и дать 
рекомендации по тому, как увеличить ретеншн каждого из сегментов

- ретеншн: retention7 = # посмотревших сегодня / # в первый раз посмотревших 7 дней назад * 100%
*/

-- сегментируем по частоте и длительности просмотров
with user_segments as ( select user_id, last_show,
							   ntile(2) over (order by duration) as duration_rank, -- "топорные" сегменты часто-редко, много-мало
							   ntile(2) over (order by frequency) as frequency_rank, -- для сегментации "вручную" нужно больше изучить датасет
		                from (select user_id,
				 	 				 avg(show_duration) as duration,
				 	 				 count(*) as frequency
				 	 				 date_trunc('day', max(show_date)) as last_show,
				 	 				 date_trunc('day',min(show_date)) as first_show
			  				  from content_watch
			  				  group by user_id
			  				  having first_show = now()::date - N
)
select count(*) as retention from user_segments
group by last_show
order by last_show;

/*
 Возможные рекомендации по сегментам:
F D Гипотеза                                      Рекомендация

1 1 Интересует только один сериал                 Показать похожие, как только закончится текущий сериал 
1 2 Смотрят кино дома по выходным                 напомнить про возможность смотреть HD на разных языках 
2 1 Мультики по утрам/вечерам                     Больше рекомендовать контент, где очень много серий?
2 2 Смотрят еще и по будням по дороге не работу   Субтитры и офлайн воспроизведение для мобильных 

 */